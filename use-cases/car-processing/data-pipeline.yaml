apiVersion: 0.3.0
meta:
  name: car-processing
  version: 0.1.0
  namespace: examples

config:
  converter: json
  consumer:
    default_starting_offset:
      value: 0
      position: End

types:
  car:
    type: object
    properties:
      maker:
        type: string
      model:
        type: string
      color:
        type: string
      license:
        type: string
      location:
        type: string
      mph:
        type: u32
      timestamp:
        type: string
  maker:
    type: object
    properties:
      maker:
        type: string
      country:
        type: string
      continent:
        type: string
  car-location:
    type: object
    properties:
      car:
        type: string
      color:
        type: string
      location:
        type: string
  color:
    type: object 
    properties:
      color: 
        type: string
      count:
        type: u32
  car-colors:
    type: list
    items:
      type: color

topics:
  cars:
    schema:
      value:
        type: car
  makers:
    schema:
      value:
        type: maker
  speeding:
    schema:
      value:
        type: car
  saratoga:
    schema:
      value:
        type: car-location
  sunnyvale:
    schema:
      value:
        type: car-location
  car-colors:
    schema:
      value:
        type: car-colors

  

services:

  # Call to an HTTP server to identify a car maker
  lookup-maker:
    sources:
      - type: topic
        id: cars

    transforms:
      steps:
        - operator: map
          adaptors:
            - http
          run: |
            fn get_car_maker(car: Car) -> Result<Maker, String> {
              let maker = car.maker.replace(" ", "%20");
              let url = format!("https://demo-data.infinyon.com/api/maker/{maker}");
              let request = ssdk_http::http::Request::builder().uri(url).body("")
                .map_err(|e| e.to_string())?;

              let response = ssdk_http::blocking::send(request).map_err(|e| e.to_string())?;
              let body = response.into_body();

              let m: Maker = serde_json::from_slice(&*body).map_err(|err| err.to_string())?;
              Ok(m)
            }

    sinks:
      - type: topic
        id: makers


  # Find speeding cars
  speeding-cars: 
    sources:
      - type: topic
        id: cars

    transforms:
      steps:
        - operator: filter
          run: |
            fn is_speeding(car: Car) -> Result<bool, String> {
              Ok(car.mph > 45)
            }

    sinks:
      - type: topic
        id: speeding


  # Split cars into 2 streams based on location
  divide-by-location:
    sources:
      - type: topic
        id: cars

    transforms:
      steps:
        - operator: map
          run: |
            fn get_car_location(car: Car) -> Result<CarLocation, String> {
              Ok(CarLocation {
                car: format!("{} {}", car.maker, car.model),
                color: car.color,
                location: car.location,
              })
            }

    sinks:
      - type: topic
        id: saratoga
        steps:
          - operator: filter
            run: |
              fn is_saratoga(cl: CarLocation) -> Result<bool, String> {
                Ok(cl.location == "Saratoga")
              }
      - type: topic
        id: sunnyvale
        steps:
          - operator: filter
            run: |
              fn is_sunnyvale(cl: CarLocation) -> Result<bool, String> {
                Ok(cl.location == "Sunnyvale")
              }

  # Find speeding cars
  count-by-color: 
    sources:
      - type: topic
        id: sunnyvale

    states:
      - name: count-by-color
        type: keyed-state
        properties:
          key:
            type: string
          value:
            type: u32

    transforms:
      window:
        tumbling:
          duration: 30s

      steps:
        - operator: assign-key
          run: |
            fn key_by_color(cl: CarLocation) -> Result<String, String> {
              Ok(cl.color)
            }

        - operator: update-state
          run: |
            fn increment_color_count(cl: CarLocation) -> Result<(), String> {
              count_by_color().increment(1);
              Ok(())
            }     

      flush:
        operator: aggregate
        run: |
          fn compute_most_used_words() -> Result<CarColors, String> {
            let mut cc = count_by_color().clone();
            Ok(cc.iter().map(| entry | Color { color: entry.key.clone(), count: entry.value }).collect())
          }

    sinks:
      - type: topic
        id: car-colors